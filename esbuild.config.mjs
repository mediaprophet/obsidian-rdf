import esbuild from 'esbuild';
import process from 'process';
import builtins from 'builtin-modules';
import { copyFile, access, mkdir } from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

const banner = `/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
If you want to view the source, please visit the github repository
https://github.com/mediaprophet/obsidian-semantic-weaver
*/
`;

const prod = process.argv[2] === 'production';

// Plugin to shim Node.js built-ins for Electron's browser context
const nodeBuiltinsPlugin = {
  name: 'node-builtins',
  setup(build) {
    const nodeBuiltins = [
      'http', 'https', 'zlib', 'stream', 'buffer', 'fs', 'url', 'net', 'util', 'path'
    ];
    // Resolve node:* and bare built-in imports to absolute paths
    nodeBuiltins.forEach(module => {
      build.onResolve({ filter: new RegExp(`^(node:)?${module}$`) }, args => ({
        path: path.resolve(__dirname, `shims/${module}.js`),
        namespace: 'file',
      }));
    });
    // Shim process and process/
    build.onResolve({ filter: /^process(\/)?$/ }, args => ({
      path: path.resolve(__dirname, 'shims/process.js'),
      namespace: 'file',
    }));
    // Handle vfile imports (minpath.js, minurl.js)
    build.onResolve({ filter: /vfile\/lib\/min(path|url)\.js$/ }, args => ({
      path: path.resolve(__dirname, `shims/${args.path.split('/').pop().replace('min', '')}.js`),
      namespace: 'file',
    }));
    // Load shim files
    build.onLoad({ filter: /shims\/.*\.js$/, namespace: 'file' }, args => {
      if (args.path.includes('shims/process.js')) {
        return {
          contents: 'module.exports = globalThis.process || {};',
          loader: 'js',
        };
      }
      if (args.path.includes('shims/path.js')) {
        return {
          contents: `
            module.exports = {
              join: (...args) => args
                .filter(segment => segment && typeof segment === 'string')
                .map(segment => segment.replace(/\/+/g, '/'))
                .join('/')
            };
          `,
          loader: 'js',
        };
      }
      return {
        contents: `module.exports = {}; // Shim for ${path.basename(args.path, '.js')} in Electron`,
        loader: 'js',
      };
    });
  },
};

const context = await esbuild.context({
  banner: {
    js: banner,
  },
  entryPoints: ['main.ts'],
  bundle: true,
  external: [
    'obsidian',
    'electron',
    'three',
    '@codemirror/autocomplete',
    '@codemirror/collab',
    '@codemirror/commands',
    '@codemirror/language',
    '@codemirror/lint',
    '@codemirror/search',
    '@codemirror/state',
    '@codemirror/view',
    ...builtins,
  ],
  format: 'cjs',
  platform: 'browser',
  target: 'es2020',
  logLevel: 'info',
  sourcemap: true, // Enable sourcemaps for debugging
  treeShaking: true,
  minify: false,
  outfile: 'main.js',
  plugins: [nodeBuiltinsPlugin],
});

async function safeCopyFile(src, dest) {
  try {
    await access(src);
    await mkdir('dist', { recursive: true });
    await copyFile(src, dest);
    console.log(`Copied ${src} to ${dest}`);
  } catch (error) {
    console.warn(`Warning: Could not copy ${src} to ${dest}: ${error.message}`);
  }
}

if (prod) {
  await context.rebuild();
  await safeCopyFile('cytoscape-context-menus.css', 'dist/cytoscape-context-menus.css');
  await safeCopyFile('styles.css', 'dist/styles.css');
  process.exit(0);
} else {
  await context.watch();
}